<!DOCTYPE html> 
<html lang="en" debug="true"> 
<head> 
   <meta charset="utf-8" />    
	<script type="text/javascript" src="mootools-core.js"></script> 
	<script type="text/javascript" src="mootools-more.js"></script> 
	<!-- <script type="text/javascript" src="https://getfirebug.com/firebug-lite.js"></script> -->
	
	<style type="text/css">
	    * {
	        font-family: sans;
	    }
	    
	    #controls {
	        float: left;
	        background: #ddd;
	    }
	    
	    #controls .outline {
	        border: 1px solid #fff;
	        height: 100%;
	        padding: 5px;
	    }
	</style>
</head>
<body id="body"> 
    <div id="log"></div>
    <script type="text/javascript">
    var map = [
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
    ];
    
    if(typeof Darkcore === 'undefined') {
        Darkcore = {};
    }
    
    Darkcore.addCanvas = function (width, height) {
        var canvas = new Element('canvas', {
            'width': Math.abs(width),
            'height': Math.abs(height),
            'position': 'absolute'
        });
        
        return canvas;
    }
    
    Darkcore.drawLine = function (fromX, fromY, toX, toY) {
        // Draw the shape
        cxt.beginPath();
        cxt.strokeStyle = '#000';
        cxt.lineWidth = 1.0;
        cxt.moveTo(fromX, fromY);
        cxt.lineTo(toX, toY);
        cxt.stroke();
        cxt.closePath();
    };
    
    Darkcore.drawCircle = function (x, y, radius, panel) {
        var canvas = Darkcore.addCanvas(radius * 2, radius * 2);
        canvas.inject($(panel));
        var context = canvas.getContext('2d');
        
        context.beginPath();
        context.arc(radius, radius, radius, 0, Math.PI*2);
        context.fill();
        
        return canvas;
    };
    
    Darkcore.clear = function (rect) {
        cxt.clearRect(rect[0],rect[1],rect[2],rect[3]);
    };
    
    Darkcore.isBlocked = function (player) {
        /*
         _____    __________________
        |_|_|_|  |-1,_-1|0,_-1|1,_-1|
        |_|_|_|  |-1,_ 0|0,_ 0|1,_ 0|
        |_|_|_|  |-1,_ 1|0,_ 1|1,_ 1|
        
        */
        var pos = Darkcore.getTilePosition(player.pos);
        var x = pos[0] * 32;
        var y = pos[1] * 32;
        
        var topLeft   = [x - 32,y - 32];
        var topCenter = [x,     y - 32];
        var topRight  = [x + 32,y - 32];
        
        var centerLeft   = [x - 32,y];
        var centerCenter = [x     ,y];
        var centerRight  = [x + 32,y];
        
        var bottomLeft     = [x - 32,y + 32];
        var bottomCenter   = [x - 0,y + 32];
        var bottomRight    = [x + 32,y + 32];
        
        
        var tiles = [
            //-- Top Row
            Darkcore.getBoundingBox(topLeft, 16),
            Darkcore.getBoundingBox(topCenter, 16),
            Darkcore.getBoundingBox(topRight, 16),
            //-- Center Row
            Darkcore.getBoundingBox(centerLeft, 16),
            Darkcore.getBoundingBox(centerCenter, 16),
            Darkcore.getBoundingBox(centerRight, 16),
            //-- Bottom Row
            Darkcore.getBoundingBox(bottomLeft, 16),
            Darkcore.getBoundingBox(bottomCenter, 16),
            Darkcore.getBoundingBox(bottomRight, 16)
        ];
        
        //-- I have to reduce the mobs' size by one or else it touches 
        // everything.
        bb0 = Darkcore.getBoundingBox(player.pos, 15);
        
        //-- Iterate though the tiles and check against the object
        var hits = [];
        for (var i = 0; i < tiles.length; i++) {
            var tile = tiles[i];
            if (Darkcore.isBoxInBox(bb0,tile)) {
                hits.push(tile);
            }
        }
        
        for(var i = 0; i < hits.length; i++) {
            var hitPos = [hits[i].x, hits[i].y];
            var tilePos = Darkcore.getTilePosition(hitPos);
            var tileId = Darkcore.getTile({
                pos: hitPos
            });
            //-- If the tile index is zero, it water, there for blocked!
            if(tileId === 0) {
                return true
            }
        }
        
        return false;
    }
    
    Darkcore.getTilePosition = function (pos) {
        //-- We use a 32x32 tile for now
        var tileLength = 32;
        var tileHalf = tileLength / 2;
        
        var x = Math.round((pos[0] - tileHalf) / tileLength);
        var y = Math.round((pos[1] - tileHalf) / tileLength);
        
        return [x, y];
    }
    
    Darkcore.getTile = function (player) {
        var tpos = Darkcore.getTilePosition(player.pos);
        var x = tpos[0];
        var y = tpos[1];
        
        b1 = Darkcore.getBoundingBox(player.pos, 32);
        b2 = Darkcore.getBoundingBox(player.pos, 32);
        
        var tile = 0;
        if(typeof map[x] !== 'undefined') {
            if(typeof map[x][y] !== 'undefined') {
                tile = map[x][y];
            }
        }
        
        return tile;
    };
    
    Darkcore.getBoundingBox = function (pos, size) {
        var x, y, w, h, half_width, half_height;
        x = pos[0] - size;
        x = x > 0 ? x : 0;

        y = pos[1] - size;
        y = y > 0 ? y : 0;

        w = (pos[0] + size) - x;
        h = (pos[1] + size) - y;

        half_width  = w !== 0 ? w / 2 : 0;
        half_height = h !== 0 ? h / 2 : 0;

        return {
            x: x,
            y: y,
            w: w,
            h: h,
            half_width: half_width,
            half_height: half_height
        }
    }
        
    Darkcore.isBoxInBox = function (b1, b2) {
        var left1, left2;
        var right1, right2;
        var top1, top2;
        var bottom1, bottom2;
            
        left1 = b1.x;
        left2 = b2.x;
        right1 = b1.x + b1.w;
        right2 = b2.x + b2.w;
        top1 = b1.y;
        top2 = b2.y;
        bottom1 = b1.y + b1.h;
        bottom2 = b2.y + b2.h;

        if (bottom1 < top2) return false;
        if (top1 > bottom2) return false;

        if (right1 < left2) return false;
        if (left1 > right2) return false;

        return true;

    }
    
    
    var Tile = new Class({});
    
    var Character = new Class({
        last_pos: [0, 0],
        pos: [7 * 32, 5 * 32],
        size: 32,
        render: function (cxt) {
            cxt.beginPath();
            cxt.fillStyle = 'rgb(0,0,0)';
            cxt.arc(this.pos[0] - 16, this.pos[1] - 16, 16, 0, 360, false);
            cxt.fill();
            cxt.closePath();
            this.last_pos = this.pos;
        },    
        Darkcore.getBoundingBox: function () {
            return Darkcore.getBoundingBox(this.pos, this.size);
        },
        move: function (x, y) {
            var tileId, tilePos, modX, modY, modChar, halfSize, pos;
            
            halfSize = this.size / 2;
            
            pos = [this.pos[0], this.pos[1]];
            
            //-- I need to fix this, the players position is always bottom right
            // and not center, grr.
            //pos[0] -= halfSize;
            //pos[1] -= halfSize;
            
            modX = pos[0];
            modY = pos[1];
            if(x != 0) {
                //modX = pos[0] + ((x > 0) ? -1 * halfSize : halfSize) + x;
                modX = pos[0] + x;
            }
            if(y != 0) {
                //modY = pos[1] + ((y > 0) ? -1 * halfSize : halfSize) + y;
                modY = pos[1] + y;
            }
    
            modChar = {
                pos: [modX, modY]
            };
    
            //tileId = Darkcore.getTile(modChar);
            //tilePos = Darkcore.getTilePosition([modX, modY]);
            
            //-- If the mob is not running into a blocked item, really do move 
            // them!
            if(!Darkcore.isBlocked(modChar)) {
                this.pos[0] += x;
                this.pos[1] += y;
            }
        }
    });
    
    /*
    window.addEvent('domready', function () {
        var size = $(window).getScrollSize();
    });
    */
    
    Darkcore.canvas = Darkcore.addCanvas(640, 480);
    Darkcore.canvas.inject($(document.body));
    Darkcore.canvas.addEvent('click', function (evt) {
        var coords = this.getCoordinates();
        var x = evt.client.x - coords.left;
        var y = evt.client.y - coords.top;
        
        var tpos = Darkcore.getTilePosition([x, y]);
        var tx = tpos[0];
        var ty = tpos[1];
        
        console.log([x, y], tx, ty);
    });
    Darkcore.context = Darkcore.canvas.getContext('2d');
    cxt = Darkcore.context;
    player = new Character();
    
    
    $(window).addEvent('keydown', function (evt) {
        //console.log(evt);
        
        if(evt.key === 'right') {
            player.move(4, 0);
            evt.stop();
        } else if(evt.key === 'left') {
            player.move(-4, 0);
            evt.stop();
        } else if(evt.key === 'up') {
            player.move(0, -4);
            evt.stop();
        } else if(evt.key === 'down') {
            player.move(0, 4);
            evt.stop();
        }
        
    });
    
    (function () {
        for (var x = 0; x < map.length; x++) {
            for (var y = 0; y < map[x].length; y++) {
                var tile = map[x][y];
                var img = new Image(32, 32);
                img.src = tile + '.png';
                //-- Render the tile
                cxt.drawImage(img, x * 32, y * 32);
                //-- Render the lines of the tile
                Darkcore.drawLine((x * 32), (y * 32), (x * 32) + 32, (y * 32));
                Darkcore.drawLine((x * 32), (y * 32), (x * 32), (y * 32) + 32);
            }
        }
        //-- Render the player after the tile
        player.render(cxt);
    }).periodical(50);
    </script>
</body>
</html>
